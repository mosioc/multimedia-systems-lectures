---
title: MMS 
layout: persian
---

# آموزش مبانی چندرسانه‌ای 

این درسنامه بر مبنای فصول مشخص شده از کتاب Ze-Nian Li, Mark S. Drew, Jiangchuan Liu با تأکید بر توضیحات عمیق، فرمول‌ها و مثال‌های مرتبط از متن کتاب ارائه می‌شود.

* [آموزش مبانی چندرسانه‌ای](#آموزش-مبانی-چندرسانه‌ای)
    * [فصل 1: آشنایی با چندرسانه‌ای (Introduction to Multimedia) - صفحه 13 به بعد](#فصل-1-آشنایی-با-چندرسانه‌ای-introduction-to-multimedia---صفحه-13-به-بعد)
        * [1.1 چندرسانه‌ای چیست؟ (What is Multimedia?)](#11-چندرسانه‌ای-چیست-what-is-multimedia)
        * [1.2 تاریخچه مختصر و توسعه چندرسانه‌ای (A Brief History and Development of Multimedia)](#12-تاریخچه-مختصر-و-توسعه-چندرسانه‌ای-a-brief-history-and-development-of-multimedia)
        * [1.3 کاربردهای چندرسانه‌ای (Applications of Multimedia)](#13-کاربردهای-چندرسانه‌ای-applications-of-multimedia)
        * [1.4 جنبه‌های فنی چندرسانه‌ای (Technical Aspects of Multimedia)](#14-جنبه‌های-فنی-چندرسانه‌ای-technical-aspects-of-multimedia)
    * [فصل 2: درک اصول بصری و سیستم‌های تصویر (Understanding Visual and Image Systems) - به طور خلاصه و با تمرکز بر چشم، نور و رنگ - صفحه 81 به بعد](#فصل-2-درک-اصول-بصری-و-سیستم‌های-تصویر-understanding-visual-and-image-systems---به-طور-خلاصه-و-با-تمرکز-بر-چشم-نور-و-رنگ---صفحه-81-به-بعد)
        * [2.1 ساختار چشم انسان و سیستم بینایی (The Human Visual System - HVS)](#21-ساختار-چشم-انسان-و-سیستم-بینایی-the-human-visual-system---hvs)
        * [2.2 نور و رنگ (Light and Color)](#22-نور-و-رنگ-light-and-color)
    * [فصل 6: صوتیات (Audio) - صفحه 149 به بعد](#فصل-6-صوتیات-audio---صفحه-149-به-بعد)
        * [6.1 دیجیتالی کردن صدا (Digitization of Sound) - صفحه 159](#61-دیجیتالی-کردن-صدا-digitization-of-sound---صفحه-159)
        * [6.2 سنتز صدا (Audio Synthesis) - صفحه 150](#62-سنتز-صدا-audio-synthesis---صفحه-150)
        * [6.3 فرمت‌های فایل صوتی (Audio File Formats) - صفحه 165](#63-فرمت‌های-فایل-صوتی-audio-file-formats---صفحه-165)
    * [فصل 7: فشرده‌سازی داده‌های چندرسانه‌ای (Multimedia Data Compression) - صفحه 271 به بعد](#فصل-7-فشرده‌سازی-داده‌های-چندرسانه‌ای-multimedia-data-compression---صفحه-271-به-بعد)
        * [7.1 مقدمه (Introduction) - صفحه 271](#71-مقدمه-introduction---صفحه-271)
        * [7.2 انواع فشرده‌سازی (Types of Compression)](#72-انواع-فشرده‌سازی-types-of-compression)
        * [7.3 افزونگی داده‌ها (Data Redundancy) - صفحه 272](#73-افزونگی-داده‌ها-data-redundancy---صفحه-272)
        * [7.4 مدل‌های فشرده‌سازی عمومی (General Compression Models) - صفحه 273](#74-مدل‌های-فشرده‌سازی-عمومی-general-compression-models---صفحه-273)
        * [7.5 الگوریتم‌های فشرده‌سازی بدون فقدان (Lossless Compression Algorithms)](#75-الگوریتم‌های-فشرده‌سازی-بدون-فقدان-lossless-compression-algorithms)
    * [فصل 8: فشرده‌سازی تصویر (Image Compression) - صفحه 285 تا انتهای 8.5](#فصل-8-فشرده‌سازی-تصویر-image-compression---صفحه-285-تا-انتهای-85)
        * [8.1 مقدمه (Introduction) - صفحه 285](#81-مقدمه-introduction---صفحه-285)
        * [8.2 استانداردهای فشرده‌سازی تصویر (Image Compression Standards) - صفحه 286](#82-استانداردهای-فشرده‌سازی-تصویر-image-compression-standards---صفحه-286)
        * [8.3 چارچوب فشرده‌سازی تصویر (Image Compression Framework) - صفحه 287](#83-چارچوب-فشرده‌سازی-تصویر-image-compression-framework---صفحه-287)
        * [8.4 فشرده‌سازی JPEG (JPEG Compression) - صفحه 287](#84-فشرده‌سازی-jpeg-jpeg-compression---صفحه-287)
        * [8.5 مفاهیم تبدیل کسینوسی گسسته (DCT Concepts) - صفحه 291](#85-مفاهیم-تبدیل-کسینوسی-گسسته-dct-concepts---صفحه-291)
    * [فصل 9: فشرده‌سازی ویدئو (Video Compression) - فقط 9.1 - صفحه 303](#فصل-9-فشرده‌سازی-ویدئو-video-compression---فقط-91---صفحه-303)
        * [9.1 مقدمه به فشرده‌سازی ویدئو (Introduction to Video Compression)](#91-مقدمه-به-فشرده‌سازی-ویدئو-introduction-to-video-compression)

---

## فصل 1: آشنایی با چندرسانه‌ای (Introduction to Multimedia) - صفحه 13 به بعد

این فصل به معرفی جامع چندرسانه‌ای، تعریف دقیق آن، و جایگاه آن در اکوسیستم فناوری مدرن می‌پردازد.

### 1.1 چندرسانه‌ای چیست؟ (What is Multimedia?)

کتاب چندرسانه‌ای را به عنوان "**هر برنامه‌ای که از چندین شیوه (modalities) شامل متن، تصاویر، نقاشی‌ها، گرافیک، انیمیشن، ویدئو و صدا (که شامل گفتار نیز می‌شود) استفاده می‌کند**" تعریف می‌کند. مهم‌ترین ویژگی که اغلب با چندرسانه‌ای همراه است، **تعاملی بودن (Interactivity)** است. این قابلیت تعامل، چندرسانه‌ای را از رسانه‌های سنتی مانند کتاب یا تلویزیون متمایز می‌کند.

**مثال از کتاب (Figure 1.1, page 14):** یک وب‌سایت خبری مدرن یا یک برنامه آموزشی تعاملی می‌تواند یک نمونه عالی از چندرسانه‌ای باشد. این وب‌سایت نه تنها متن (اخبار) دارد، بلکه شامل تصاویر خبری، ویدئوهای مصاحبه، و لینک‌های تعاملی برای کاوش بیشتر است.

### 1.2 تاریخچه مختصر و توسعه چندرسانه‌ای (A Brief History and Development of Multimedia)

کتاب به تحول از کامپیوترهای متنی به سیستم‌های گرافیکی و در نهایت به چندرسانه‌ای اشاره دارد.

* **دهه 1980:** کامپیوترها عمدتاً متنی بودند. ظهور سیستم‌های گرافیکی (مانند GUI در Macintosh و Windows) گام بزرگی بود.
* **دهه 1990:** پیشرفت در قدرت پردازشی و ذخیره‌سازی، امکان ادغام صدا و ویدئو را فراهم کرد. **CD-ROM** و سپس **DVD** بستر مناسبی برای توزیع محتوای چندرسانه‌ای آفلاین بودند.
* **دهه 2000 به بعد:** **اینترنت پرسرعت** و **دستگاه‌های موبایل**، چندرسانه‌ای را به یک پدیده فراگیر تبدیل کردند. استریمینگ ویدئو، کنفرانس‌های صوتی/تصویری، و شبکه‌های اجتماعی چندرسانه‌ای به اجزای جدایی‌ناپذیر زندگی روزمره تبدیل شدند.

### 1.3 کاربردهای چندرسانه‌ای (Applications of Multimedia)

کتاب طیف وسیعی از کاربردها را برمی‌شمرد که نشان‌دهنده فراگیر بودن چندرسانه‌ای است:

* **سرگرمی (Entertainment):** بازی‌های ویدئویی (شامل گرافیک، صدا، انیمیشن و تعامل)، فیلم‌های استریمینگ (Netflix، YouTube)، موسیقی دیجیتال (Spotify)، واقعیت مجازی (VR) و واقعیت افزوده (AR).
* **آموزش (Education):** E-learning (آموزش الکترونیکی)، شبیه‌سازها (مثل شبیه‌ساز پرواز)، کتاب‌های درسی تعاملی (Interactive eBooks).
* **کسب‌وکار (Business):** ارائه‌های چندرسانه‌ای، کنفرانس‌های ویدئویی، بازاریابی و تبلیغات تعاملی، آموزش کارکنان.
* **پزشکی (Medicine):** آموزش جراحی، سیستم‌های تصویربرداری پزشکی (MRI، CT Scan) با تجسم سه‌بعدی.
* **مهندسی (Engineering):** طراحی به کمک کامپیوتر (CAD) با مدل‌سازی سه‌بعدی و شبیه‌سازی، شبیه‌سازی‌های مهندسی.
* **رسانه و روزنامه‌نگاری (Media and Journalism):** وب‌سایت‌های خبری با ویدئو، گالری تصاویر و اینفوگرافیک‌های تعاملی.

### 1.4 جنبه‌های فنی چندرسانه‌ای (Technical Aspects of Multimedia)

کتاب بر اهمیت درک ابعاد فنی چندرسانه‌ای از دیدگاه علوم کامپیوتر تأکید می‌کند. چندرسانه‌ای به عنوان یک "**حوزه کاربردی افقی (horizontal application area)**" توصیف می‌شود، به این معنی که از رشته‌های مختلف علوم کامپیوتر و مهندسی بهره می‌برد و آن‌ها را به هم پیوند می‌دهد.

سه حوزه اصلی فنی:

1.  **پردازش و کدگذاری چندرسانه‌ای (Multimedia Processing and Coding):**
    * **الگوریتم‌های فشرده‌سازی (Compression Algorithms):** مانند JPEG برای تصویر، MPEG برای ویدئو، و MP3 برای صدا. این الگوریتم‌ها برای کاهش حجم داده‌ها حیاتی هستند.
    * **تحلیل محتوای چندرسانه‌ای (Multimedia Content Analysis):** استخراج اطلاعات معنی‌دار از محتوای چندرسانه‌ای (مانند تشخیص چهره در تصاویر یا گفتار در فایل‌های صوتی).
    * **بازیابی محتوای چندرسانه‌ای (Content-Based Multimedia Retrieval):** جستجوی تصاویر یا ویدئوها بر اساس محتوای بصری یا صوتی آن‌ها، نه فقط فراداده (metadata).
    * **امنیت چندرسانه‌ای (Multimedia Security):** شامل واتر مارکینگ (watermarking) برای محافظت از کپی‌رایت و استگانوگرافی (steganography) برای پنهان‌سازی اطلاعات.
2.  **پشتیبانی سیستم و شبکه چندرسانه‌ای (Multimedia System Support and Networking):**
    * **پروتکل‌های شبکه (Network Protocols):** مانند TCP/IP و UDP که برای انتقال روان و به موقع داده‌های چندرسانه‌ای (به ویژه در استریمینگ) ضروری هستند.
    * **شبکه‌های اینترنت و بی‌سیم (Internet and Wireless Networks):** زیرساخت‌های لازم برای توزیع محتوای چندرسانه‌ای.
    * **سیستم‌عامل‌ها، سرورها و کلاینت‌ها (Operating Systems, Servers, and Clients):** معماری‌های نرم‌افزاری و سخت‌افزاری برای ارائه خدمات چندرسانه‌ای.
    * **پایگاه داده‌های چندرسانه‌ای (Multimedia Databases):** سیستم‌هایی برای ذخیره و مدیریت کارآمد حجم عظیمی از داده‌های چندرسانه‌ای.
3.  **ابزارها، سیستم‌های نهایی و کاربردهای چندرسانه‌ای (Multimedia Tools, End Systems, and Applications):**
    * **سیستم‌های فرارسانه (Hypermedia Systems):** ساختارهای غیرخطی از اطلاعات که به کاربر اجازه می‌دهند در میان محتوای مرتبط حرکت کند (مانند وب‌سایت‌ها).
    * **رابط‌های کاربری (User Interfaces):** طراحی رابط‌های کاربری جذاب و شهودی برای برنامه‌های چندرسانه‌ای.
    * **سیستم‌های تألیف (Authoring Systems):** ابزارهایی برای ایجاد و سازماندهی محتوای چندرسانه‌ای (مثلاً Adobe Premiere برای ویرایش ویدئو).
    * **تعامل چندوجهی (Multimodal Interaction):** استفاده از چندین شیوه ورودی و خروجی (مثلاً گفتار، لمس، ژست) برای تعامل کاربر.
    * **دستگاه‌های فراگیر (Ubiquitous Devices):** مانند گوشی‌های هوشمند، تبلت‌ها و ساعت‌های هوشمند که امکان مصرف و تولید محتوای چندرسانه‌ای را در هر زمان و مکان فراهم می‌کنند.

**خلاصه فصل 1:** چندرسانه‌ای یک زمینه پویا و رو به رشد است که ترکیب رسانه‌های مختلف را با قابلیت تعامل فراهم می‌کند. این حوزه نیازمند درک عمیق از جنبه‌های پردازش، سیستم‌ها و ابزارها است تا بتواند چالش‌های مدیریت حجم عظیم داده‌های چندرسای را برطرف کند.

---

## فصل 2: درک اصول بصری و سیستم‌های تصویر (Understanding Visual and Image Systems) - به طور خلاصه و با تمرکز بر چشم، نور و رنگ - صفحه 81 به بعد

این فصل به مبانی درک بصری، ماهیت نور و رنگ، و چگونگی نمایش تصاویر دیجیتال می‌پردازد. در این بخش، بر ساختار چشم انسان و مدل‌های نور و رنگ تأکید می‌شود.

### 2.1 ساختار چشم انسان و سیستم بینایی (The Human Visual System - HVS)

کتاب اشاره می‌کند که چشم انسان، به عنوان حسگر اصلی ما برای درک تصاویر، دارای ویژگی‌هایی است که الگوریتم‌های فشرده‌سازی از آن‌ها بهره می‌برند.

**ساختار اصلی چشم:**
* **قرنیه (Cornea) و عدسی (Lens):** مسئول متمرکز کردن نور روی شبکیه هستند.
* **عنبیه (Iris):** اندازه مردمک (Pupil) را کنترل می‌کند تا میزان نور ورودی به چشم تنظیم شود.
* **شبکیه (Retina):** لایه حساس به نور در پشت چشم که حاوی دو نوع سلول گیرنده نور است:
    * **سلول‌های میله‌ای (Rods):**
        * حدود 120 میلیون عدد.
        * بسیار حساس به نور، مسئول دید در نور کم (دید شب) و تشخیص حرکت.
        * قادر به تشخیص رنگ نیستند و فقط اطلاعات سیاه و سفید را منتقل می‌کنند.
        * در محیط شبکیه (به جز نقطه مرکزی) متمرکز شده‌اند.
    * **سلول‌های مخروطی (Cones):**
        * حدود 6 تا 7 میلیون عدد.
        * مسئول دید در نور روشن و تشخیص رنگ.
        * سه نوع مخروط وجود دارد که هر کدام به طول موج‌های مختلفی از نور حساس هستند:
            * **L-cones (Long wavelength):** حساس به نور قرمز (Red).
            * **M-cones (Medium wavelength):** حساس به نور سبز (Green).
            * **S-cones (Short wavelength):** حساس به نور آبی (Blue).
        * بیشتر در نقطه مرکزی شبکیه، یعنی **لکه زرد (Fovea)**، متمرکز شده‌اند که ناحیه دید واضح و دقیق ماست.
* **عصب بینایی (Optic Nerve):** اطلاعات بصری را از شبکیه به مغز منتقل می‌کند.

**ویژگی‌های HVS که برای فشرده‌سازی مهم هستند:**
کتاب بر این دو مشاهده مهم تأکید می‌کند (صفحه 287، بخش 8.3):

* **حساسیت کمتر به فرکانس‌های فضایی بالا (Less sensitivity to high spatial frequencies):** چشم انسان به جزئیات بسیار ظریف و تغییرات سریع در تصویر (فرکانس‌های بالا) حساسیت کمتری دارد. این مشاهده به الگوریتم‌های فشرده‌سازی با فقدان اجازه می‌دهد تا اطلاعات فرکانس بالا را حذف یا با دقت کمتری ذخیره کنند.
* **حساسیت کمتر به جزئیات رنگی نسبت به روشنایی (Less sensitivity to color details than to luminance):** چشم انسان برای تشخیص جزئیات ریز (visual acuity) به مؤلفه روشنایی (Luminance) بسیار حساس‌تر است تا مؤلفه‌های رنگی (Chrominance). این پایه و اساس تکنیک **Chroma Subsampling** است که در JPEG و استانداردهای ویدئویی استفاده می‌شود.

### 2.2 نور و رنگ (Light and Color)

* **نور:** نوعی از انرژی الکترومغناطیسی که در یک طیف خاص از طول موج‌ها (حدود 400 نانومتر (بنفش) تا 700 نانومتر (قرمز)) برای چشم انسان قابل رؤیت است.
* **رنگ (Color):** یک پدیده ادراکی است که توسط مغز ما در پاسخ به طول موج‌های مختلف نور تفسیر می‌شود.
    * **Hue (فام/ته‌رنگ):** رنگ خالص (مثل قرمز، سبز، آبی).
    * **Saturation (اشباع):** خلوص رنگ (میزان رنگ خالص در مقابل سفید).
    * **Brightness/Luminance (روشنایی):** شدت کلی نور.

**مدل‌های رنگی (Color Models):**

1.  **مدل رنگی افزایشی (Additive Color Model - RGB):**
    * **اساس:** ترکیب نورهای رنگی (قرمز، سبز، آبی) برای تولید رنگ‌های دیگر.
    * **کاربرد:** در نمایشگرها (مانیتورها، تلویزیون‌ها، پروژکتورها) که نور منتشر می‌کنند.
    * **مثال:** `R=255, G=0, B=0` (قرمز خالص)، `R=255, G=255, B=0` (زرد). ترکیب هر سه رنگ با شدت کامل (`R=255, G=255, B=255`) رنگ سفید را تولید می‌کند.
2.  **مدل رنگی کاهشی (Subtractive Color Model - CMY/CMYK):**
    * **اساس:** جذب طول موج‌های خاصی از نور توسط جوهرها یا رنگدانه‌ها.
    * **کاربرد:** در چاپگرها و نقاشی که نور بازتابیده می‌شود.
    * **CMY:** Cyan (فیروزه‌ای), Magenta (سرخابی), Yellow (زرد). ترکیب هر سه رنگ CMY به طور ایده‌آل سیاه را تولید می‌کند.
    * **CMYK:** (Cyan, Magenta, Yellow, Black) برای دستیابی به سیاه غنی‌تر و بهبود کیفیت چاپ اضافه می‌شود.
3.  **مدل‌های مبتنی بر روشنایی و رنگ (Luminance-Chrominance Models - YCbCr/YUV/YIQ):**
    * **هدف:** جداسازی مؤلفه روشنایی (Y) از مؤلفه‌های رنگی (Cb و Cr).
    * **Y (Luminance/Luma):** نشان‌دهنده شدت نور یا اطلاعات سیاه و سفید تصویر.
    * **Cb (Chroma Blue-difference):** تفاوت رنگ آبی با روشنایی.
    * **Cr (Chroma Red-difference):** تفاوت رنگ قرمز با روشنایی.
    * **کاربرد:** این مدل‌ها برای فشرده‌سازی بسیار مهم هستند، زیرا می‌توان اطلاعات رنگی (Cb و Cr) را با دقت کمتری (ساب‌سمپلینگ) ذخیره کرد، بدون اینکه افت کیفیت بصری قابل توجهی درک شود.

**خلاصه فصل 2 (خلاصه):** ساختار چشم انسان، به ویژه وجود سلول‌های میله‌ای و مخروطی، تعیین‌کننده نحوه درک ما از روشنایی و رنگ است. این تفاوت در حساسیت، به ویژه حساسیت کمتر به فرکانس‌های بالا و جزئیات رنگی، مبنای اصلی فشرده‌سازی با فقدان در تصاویر و ویدئو است. مدل‌های رنگی مانند RGB (برای نمایشگرها) و YCbCr (برای فشرده‌سازی) روش‌های مختلفی برای نمایش رنگ‌ها هستند.

---

## فصل 6: صوتیات (Audio) - صفحه 149 به بعد

این فصل به طور کامل به جنبه‌های مختلف صدا، از جمله دیجیتالی کردن، فشرده‌سازی و سنتز آن می‌پردازد.

### 6.1 دیجیتالی کردن صدا (Digitization of Sound) - صفحه 159

همانطور که قبلاً اشاره شد، برای اینکه کامپیوتر بتواند با صدا کار کند، سیگنال صوتی آنالوگ باید به فرم دیجیتال تبدیل شود. این فرآیند از سه مرحله اصلی تشکیل شده است:

#### 6.1.1 نمونه‌برداری (Sampling)

* **هدف:** تبدیل سیگنال صوتی پیوسته در زمان (مثلاً یک موج آنالوگ از میکروفون) به یک دنباله گسسته از مقادیر.
* **پروسه:** دامنه سیگنال آنالوگ در فواصل زمانی منظم و با فواصل یکسان اندازه‌گیری می‌شود. هر اندازه‌گیری یک "**نمونه**" (sample) است.
* **نرخ نمونه‌برداری (Sampling Rate):** تعداد نمونه‌هایی که در هر ثانیه گرفته می‌شود. واحد آن هرتز (Hz) یا کیلوهرتز (kHz) است.
    * **مثال از کتاب (Figure 6.13a, page 160):** شکل 6.13a یک سیگنال آنالوگ را نشان می‌دهد. با انتخاب نقاطی در فواصل زمانی منظم (مثلاً هر 0.2 میلی‌ثانیه)، نمونه‌ها از سیگنال گرفته می‌شوند.
* **قضیه نایکوئیست (Nyquist Theorem):** این قضیه اساسی برای بازسازی دقیق یک سیگنال آنالوگ از نمونه‌های دیجیتال است.
    * **فرمول (صفحه 160):** برای بازسازی دقیق یک سیگنال با بالاترین فرکانس $F_{max}$، نرخ نمونه‌برداری $F_s$ باید حداقل دو برابر $F_{max}$ باشد:
        $$F_s \ge 2F_{max}$$
    * **مثال (صفحه 161):**
        * **تلفن:** بالاترین فرکانس قابل انتقال حدود 4 kHz است. بنابراین، نرخ نمونه‌برداری نایکوئیست حداقل 8 kHz است. استانداردهای تلفن معمولاً از 8 kHz استفاده می‌کنند.
        * **کیفیت CD:** بالاترین فرکانس قابل شنیدن توسط انسان حدود 20 kHz است. بنابراین، نرخ نمونه‌برداری نایکوئیست حداقل 40 kHz است. نرخ نمونه‌برداری CD برابر با 44.1 kHz است که این شرط را برآورده می‌کند.
* **پدیده Aliasing:** اگر نرخ نمونه‌برداری کمتر از نرخ نایکوئیست باشد، فرکانس‌های بالا به صورت فرکانس‌های پایین "اشتباه" بازسازی می‌شوند که به آن Aliasing می‌گویند. این پدیده باعث از دست رفتن اطلاعات و ایجاد نویز می‌شود. برای جلوگیری از آن، معمولاً قبل از نمونه‌برداری از فیلتر پایین‌گذر (Low-pass filter) استفاده می‌شود.

#### 6.1.2 کوانتیزاسیون (Quantization)

* **هدف:** تبدیل مقادیر دامنه هر نمونه (که هنوز پیوسته هستند) به یک مقدار گسسته و محدود.
* **پروسه:** دامنه کلی سیگنال به تعدادی **سطح کوانتیزاسیون (Quantization Levels)** تقسیم می‌شود. هر نمونه پیوسته به نزدیک‌ترین سطح کوانتیزاسیون گرد می‌شود.
* **عمق بیت (Bit Depth)** یا رزولوشن کوانتیزاسیون: تعداد بیت‌هایی که برای نمایش هر نمونه کوانتیزه شده استفاده می‌شود. اگر $N$ بیت استفاده شود، $2^N$ سطح کوانتیزاسیون وجود دارد.
    * **مثال (Figure 6.13b, page 160):** در شکل 6.13b، دامنه به 8 سطح کوانتیزاسیون (برای 3 بیت) تقسیم شده است. هر نمونه به نزدیک‌ترین سطح گرد می‌شود.
* **نویز کوانتیزاسیون (Quantization Noise):** تفاوت بین مقدار آنالوگ اصلی و مقدار کوانتیزه شده، که یک خطای اجتناب‌ناپذیر در این فرآیند است و به صورت نویز ظاهر می‌شود.
* **نسبت سیگنال به نویز کوانتیزاسیون (Signal-to-Quantization Noise Ratio - SQNR):** معیاری برای سنجش کیفیت کوانتیزاسیون. هر بیت اضافی در عمق بیت، SQNR را حدود 6.02 دسی‌بل (dB) بهبود می‌بخشد.
    * **فرمول تقریبی SQNR (صفحه 162):**
        $$\text{SQNR} \approx 6.02N + 1.76 \text{ dB}$$
        که $N$ عمق بیت است.
    * **مثال (صفحه 162):**
        * برای $N=8$ بیت: $\text{SQNR} \approx 6.02 \times 8 + 1.76 = 49.92 \text{ dB}$.
        * برای $N=16$ بیت (کیفیت CD): $\text{SQNR} \approx 6.02 \times 16 + 1.76 = 98.08 \text{ dB}$. این مقدار بالای SQNR نشان‌دهنده کیفیت بسیار خوب صدای CD است.

#### 6.1.3 کدگذاری (Encoding)

* **هدف:** تبدیل مقادیر کوانتیزه شده به یک جریان از بیت‌ها (bitstream) برای ذخیره‌سازی یا انتقال. رایج‌ترین روش **مدولاسیون کد پالس (Pulse Code Modulation - PCM)** است که در آن هر نمونه کوانتیزه شده مستقیماً به عنوان یک عدد باینری کدگذاری می‌شود.
* **حجم داده صوتی دیجیتال (صفحه 162):**
    حجم داده برای $T$ ثانیه صدا با نرخ نمونه‌برداری $F_s$، عمق بیت $N$ و $C$ کانال (1 برای مونو، 2 برای استریو) به صورت زیر محاسبه می‌شود:
    $$\text{Total bits} = F_s \times N \times C \times T$$
    * **مثال (برای یک دقیقه صوت با کیفیت CD):**
        * $F_s = 44.1 \text{ kHz} = 44,100 \text{ samples/second}$
        * $N = 16 \text{ bits/sample}$
        * $C = 2 \text{ (stereo)}$
        * $T = 60 \text{ seconds}$
        * $\text{Total bits} = 44,100 \times 16 \times 2 \times 60 = 84,672,000 \text{ bits}$
        * $\text{Total bytes} = 84,672,000 / 8 = 10,584,000 \text{ bytes}$
        * $\text{Total MB} = 10,584,000 / (1024 \times 1024) \approx 10.1 \text{ MB}$

### 6.2 سنتز صدا (Audio Synthesis) - صفحه 150

این بخش به روش‌های تولید صدا به صورت مصنوعی اشاره دارد:

* **سنتز FM (Frequency Modulation Synthesis):** تولید صدا با مدوله کردن فرکانس یک موج حامل با یک موج مدوله‌کننده. قادر به تولید صداهای پیچیده و هارمونیک‌های غنی است.
* **جدول موج (Wave-Table Synthesis):** ذخیره نمونه‌های دیجیتالی از یک ساز یا منبع صوتی در یک جدول (wave-table) و سپس بازپخش و تغییر (interpolation) این نمونه‌ها برای ایجاد صداهای جدید.
* **سنتز فیزیکی (Physical Modeling Synthesis):** شبیه‌سازی فیزیک سازهای موسیقی یا منابع صوتی برای تولید صدا.

### 6.3 فرمت‌های فایل صوتی (Audio File Formats) - صفحه 165

* **WAV (Waveform Audio File Format):** فرمت استاندارد برای ذخیره صدای دیجیتال خام و غیرفشرده در ویندوز. حجم فایل بالا است.
* **AIFF (Audio Interchange File Format):** معادل WAV در سیستم‌عامل Macintosh.
* **MP3 (MPEG-1 Audio Layer 3):** یک فرمت فشرده‌سازی با فقدان محبوب. از **مدل روان‌شنوایی (psychoacoustic model)** برای حذف اطلاعاتی که گوش انسان نمی‌شنود یا کمتر به آن حساس است، استفاده می‌کند.
* **AAC (Advanced Audio Coding):** فرمت فشرده‌سازی با فقدان که در iPod و iTunes استفاده می‌شود و معمولاً در نرخ بیت‌های مشابه، کیفیت بهتری نسبت به MP3 ارائه می‌دهد.

**خلاصه فصل 6:** دیجیتالی کردن صدا شامل نمونه‌برداری، کوانتیزاسیون و کدگذاری است که نرخ نمونه‌برداری و عمق بیت تعیین‌کننده کیفیت هستند. سنتز صدا امکان تولید مصنوعی صداها را فراهم می‌کند و فرمت‌های مختلفی برای ذخیره‌سازی صدا (فشرده و غیرفشرده) وجود دارد.

---

## فصل 7: فشرده‌سازی داده‌های چندرسانه‌ای (Multimedia Data Compression) - صفحه 271 به بعد

این فصل به اصول و الگوریتم‌های فشرده‌سازی داده‌ها می‌پردازد.

### 7.1 مقدمه (Introduction) - صفحه 271

**فشرده‌سازی (Compression)** به فرآیند کاهش حجم داده‌ها بدون از دست دادن اطلاعات حیاتی (یا با از دست دادن قابل قبول) اشاره دارد.

* **چرایی فشرده‌سازی:** همانطور که قبلاً بحث شد، برای کاهش فضای ذخیره‌سازی و پهنای باند لازم برای انتقال.
* **نرخ فشرده‌سازی (Compression Ratio):** نسبت حجم داده‌های اصلی به حجم داده‌های فشرده شده. هرچه این نسبت بزرگتر باشد، فشرده‌سازی بهتر است.
    * **فرمول (صفحه 271):**
        $$\text{CR} = \frac{\text{Original Data Size}}{\text{Compressed Data Size}}$$
        یا گاهی به صورت درصد:
        $$\text{CR} = \left(1 - \frac{\text{Compressed Data Size}}{\text{Original Data Size}}\right) \times 100\%$$

### 7.2 انواع فشرده‌سازی (Types of Compression)

* **فشرده‌سازی بدون فقدان (Lossless Compression):**
    * **تعریف:** امکان بازسازی دقیق و کامل داده‌های اصلی از داده‌های فشرده شده. هیچ اطلاعاتی از دست نمی‌رود.
    * **کاربرد:** برای داده‌هایی که نیاز به دقت کامل دارند (مانند فایل‌های متنی، برنامه‌های اجرایی، تصاویر پزشکی، داده‌های علمی).
    * **مثال:** RLE, Huffman, LZW, ZIP, PNG.
* **فشرده‌سازی با فقدان (Lossy Compression):**
    * **تعریف:** بخشی از اطلاعات (معمولاً اطلاعاتی که برای درک انسان کمتر مهم هستند) به طور دائمی حذف می‌شوند. بازسازی دقیق داده‌های اصلی ممکن نیست.
    * **کاربرد:** برای داده‌های چندرسانه‌ای (تصاویر، ویدئو، صدا) که مصرف‌کننده نهایی آن‌ها انسان است و مقداری از دست دادن کیفیت قابل قبول است.
    * **مزیت:** دستیابی به نسبت‌های فشرده‌سازی بسیار بالاتر.
    * **مثال:** JPEG, MPEG, MP3.

### 7.3 افزونگی داده‌ها (Data Redundancy) - صفحه 272

فشرده‌سازی بر اساس حذف انواع افزونگی‌ها عمل می‌کند:

* **افزونگی کدگذاری (Coding Redundancy):**
    * **تعریف:** زمانی که نمادهای پرکاربرد، کدهای بلندتری (مثلاً 8 بیت در ASCII) نسبت به آنچه لازم است دارند.
    * **مثال:** در یک متن، حرف 'e' بسیار بیشتر از 'z' استفاده می‌شود، اما هر دو در ASCII 8 بیت دارند.
    * **راه حل:** کدگذاری با طول متغیر (Variable-Length Coding - VLC) مانند Huffman.
* **افزونگی بین‌پیوند (Interpixel Redundancy)** یا **افزونگی فضایی (Spatial Redundancy):**
    * **تعریف:** همبستگی بالا بین مقادیر پیکسل‌های مجاور در یک تصویر. (پیکسل‌های نزدیک به هم اغلب مقادیر مشابهی دارند).
    * **راه حل:** تبدیل‌های تصویر (مانند DCT، DWT) که همبستگی را کاهش می‌دهند و اطلاعات را به صورت فشرده‌تری نمایش می‌دهند.
* **افزونگی روان‌بصری (Psychovisual Redundancy):**
    * **تعریف:** اطلاعاتی که سیستم بینایی انسان به سختی یا اصلاً قادر به درک آن‌ها نیست. این اطلاعات را می‌توان بدون تأثیر قابل توجهی بر کیفیت درک شده، حذف کرد.
    * **مثال:** فرکانس‌های فضایی بسیار بالا در تصاویر، جزئیات رنگی ریز.
    * **راه حل:** کوانتیزاسیون (Quantization) در فشرده‌سازی با فقدان.
* **افزونگی زمانی (Temporal Redundancy):**
    * **تعریف:** شباهت بین فریم‌های متوالی در یک دنباله ویدئویی.
    * **راه حل:** تخمین حرکت (Motion Estimation) و جبران حرکت (Motion Compensation) در فشرده‌سازی ویدئو.

### 7.4 مدل‌های فشرده‌سازی عمومی (General Compression Models) - صفحه 273

اکثر سیستم‌های فشرده‌سازی داده (به ویژه با فقدان) از یک مدل کلی پیروی می‌کنند:

* **Transform (تبدیل):** تبدیل داده‌ها از یک دامنه (مثلاً فضایی) به دامنه دیگر (مثلاً فرکانس) برای دکورله کردن داده‌ها و متمرکز کردن انرژی. (مانند DCT در JPEG).
* **Quantization (کوانتیزاسیون):** کاهش تعداد مقادیر ممکن برای هر داده، که منجر به فشرده‌سازی با فقدان می‌شود.
* **Entropy Coding (کدگذاری آنتروپی):** فشرده‌سازی بدون فقدان داده‌های کوانتیزه شده با بهره‌برداری از افزونگی آماری (مانند Huffman یا RLC).

### 7.5 الگوریتم‌های فشرده‌سازی بدون فقدان (Lossless Compression Algorithms)

#### 7.5.1 کدگذاری طول اجرا (Run-Length Coding - RLC) - صفحه 274

* **ایده:** جایگزینی دنباله‌های طولانی از نمادهای تکراری (runs) با یک نماد و تعداد تکرار آن.
* **مثال از کتاب (صفحه 274):**
    * رشته ورودی: `AAAAAABBBBCDDDDD`
    * خروجی RLC: `6A4B1C5D`
* **کاربرد:** برای داده‌هایی با تکرار زیاد و متوالی نمادها مفید است، مانند تصاویر سیاه و سفید (فاکس) یا ضرایب DCT صفر در JPEG.

#### 7.5.2 کدگذاری Huffman - صفحه 275

* **ایده:** یک الگوریتم کدگذاری طول متغیر است که به نمادهای پرکاربرد، کدهای باینری کوتاه‌تر و به نمادهای کم‌کاربرد، کدهای بلندتر اختصاص می‌دهد. این کار افزونگی کدگذاری را حذف می‌کند.
* **خاصیت بهینگی:** کد هافمن یک کد پیشوندی بهینه (prefix code) است. یعنی هیچ کد کوتاهی پیشوند کد بلند دیگری نیست، که امکان رمزگشایی یکتا را فراهم می‌کند.
* **پروسه (صفحه 275-276):**
    1.  **محاسبه فراوانی (Frequency Calculation):** تعداد دفعات حضور هر نماد در داده‌های ورودی را محاسبه کنید.
    2.  **ساخت گره‌ها (Node Creation):** برای هر نماد، یک گره (برگ) با فراوانی آن ایجاد کنید.
    3.  **ساخت درخت (Tree Construction):**
        * دو گره با کمترین فراوانی را انتخاب کنید.
        * یک گره والد جدید ایجاد کنید که فراوانی آن برابر با مجموع فراوانی دو گره فرزند باشد.
        * گره‌های فرزند را به گره والد وصل کنید و آن را به لیست گره‌ها اضافه کنید.
        * این فرآیند را تکرار کنید تا فقط یک گره (ریشه درخت) باقی بماند.
    4.  **تخصیص کد (Code Assignment):** از ریشه درخت شروع کنید و به سمت برگ‌ها حرکت کنید. به هر شاخه چپ '0' و به هر شاخه راست '1' (یا برعکس) اختصاص دهید. رشته بیت‌های جمع شده در مسیر از ریشه تا برگ، کد هافمن آن نماد خواهد بود.
* **مثال از کتاب (Example 7.1, page 277):**
    فرض کنید نمادها و فراوانی‌های زیر را داریم:
    * A: 0.5
    * B: 0.25
    * C: 0.125
    * D: 0.125
    مراحل ساخت درخت:
    * C(0.125), D(0.125) را ترکیب کنید -> CD(0.25)
    * B(0.25), CD(0.25) را ترکیب کنید -> BCD(0.5)
    * A(0.5), BCD(0.5) را ترکیب کنید -> All(1.0)
    کدها:
    * A: `0` (1 بیت)
    * B: `10` (2 بیت)
    * C: `110` (3 بیت)
    * D: `111` (3 بیت)
    طول متوسط کد: $(0.5 \times 1) + (0.25 \times 2) + (0.125 \times 3) + (0.125 \times 3) = 0.5 + 0.5 + 0.375 + 0.375 = 1.75$ بیت/نماد.

#### 7.5.3 کدگذاری Shannon-Fanon - صفحه 279

* **ایده:** این روش نیز یک کدگذاری طول متغیر است که به نمادهای پرکاربرد کدهای کوتاه‌تر می‌دهد، اما لزوماً بهینه نیست (در مقایسه با هافمن).
* **پروسه (صفحه 279):**
    1.  **مرتب‌سازی (Sorting):** نمادها را بر اساس فراوانی (احتمال) نزولی مرتب کنید.
    2.  **تقسیم (Dividing):** لیست نمادها را به دو زیرلیست تقسیم کنید به طوری که مجموع فراوانی‌های دو زیرلیست تا حد امکان برابر باشد. به نمادهای زیرلیست اول '0' و به نمادهای زیرلیست دوم '1' اضافه کنید.
    3.  **بازگشتی (Recursive Application):** مرحله 2 را به صورت بازگشتی بر روی هر زیرلیست تکرار کنید تا هر نماد به تنهایی در یک زیرلیست قرار گیرد.
* **مثال از کتاب (Example 7.2, page 279):**
    همان نمادهای مثال هافمن: A(0.5), B(0.25), C(0.125), D(0.125)
    مراحل:
    * A (0.5) | B (0.25) C (0.125) D (0.125)
        * A -> `0`
        * BCD -> `1`
    * B (0.25) | C (0.125) D (0.125)
        * B -> `10`
        * CD -> `11`
    * C (0.125) | D (0.125)
        * C -> `110`
        * D -> `111`
    کدها:
    * A: `0` (1 بیت)
    * B: `10` (2 بیت)
    * C: `110` (3 بیت)
    * D: `111` (3 بیت)
    در این مثال خاص، کدهای Shannon-Fanon و Huffman یکسان شدند، اما همیشه اینطور نیست.

#### 7.5.4 LZW (Lempel-Ziv-Welch) - صفحه 281

* **ایده اصلی:** فشرده‌سازی مبتنی بر دیکشنری تطبیقی/پویا. به جای نمادهای منفرد، رشته‌های تکراری از نمادها را با کدهای با طول ثابت جایگزین می‌کند.
* **پروسه (صفحه 281-282):**
    * **رمزگذار (Encoder):**
        * یک دیکشنری اولیه (مثلاً با تمام کاراکترهای ASCII) ایجاد می‌کند.
        * ورودی را کاراکتر به کاراکتر می‌خواند و طولانی‌ترین رشته‌ای را که در دیکشنری موجود است، شناسایی می‌کند.
        * کد مربوط به آن رشته را به خروجی می‌فرستد.
        * رشته جدیدی که از ترکیب "رشته شناسایی شده" و "کاراکتر بعدی" تشکیل شده است را به دیکشنری اضافه می‌کند (اگر قبلاً در دیکشنری نباشد).
        * پروسه را با "کاراکتر بعدی" به عنوان شروع رشته جدید ادامه می‌دهد.
    * **رمزگشا (Decoder):**
        * یک دیکشنری اولیه یکسان با رمزگذار ایجاد می‌کند.
        * کدهای فشرده شده را می‌خواند.
        * رشته مربوط به هر کد را از دیکشنری بازسازی می‌کند و به خروجی می‌فرستد.
        * دیکشنری خود را به طور همزمان با رمزگذار به روز می‌کند، با اضافه کردن رشته‌های جدیدی که از ترکیب "رشته بازسازی شده قبلی" و "اولین کاراکتر رشته بازسازی شده فعلی" حاصل می‌شوند.
* **مثال از کتاب (Example 7.3, page 282 - فشرده‌سازی رشته 'ABABABABA'):**
    دیکشنری اولیه: A=1, B=2, ... (فرض می‌کنیم کدهای 1 و 2).
    فشرده‌سازی:
    * اولین کاراکتر 'A'. به خروجی `1` را بفرست. رشته فعلی = "A".
    * بعدی 'B'. 'AB' را در دیکشنری جستجو کن (موجود نیست). `1` را خروجی بده. 'AB' را با کد 3 به دیکشنری اضافه کن. رشته فعلی = "B".
    * بعدی 'A'. 'BA' در دیکشنری نیست. `2` را خروجی بده. 'BA' را با کد 4 اضافه کن. رشته فعلی = "A".
    * بعدی 'B'. 'AB' در دیکشنری است (کد 3). رشته فعلی = "AB".
    * بعدی 'A'. 'ABA' در دیکشنری نیست. `3` را خروجی بده. 'ABA' را با کد 5 اضافه کن. رشته فعلی = "A".
    * ... این روند ادامه پیدا می‌کند.
    فشرده‌گشایی (Decoder):
    * کد `1` (A). خروجی A. 'prev_string' = 'A'.
    * کد `2` (B). خروجی B. 'prev_string' + 'first_char_current_string' = 'AB'. 'AB' را با کد 3 به دیکشنری اضافه کن. 'prev_string' = 'B'.
    * کد `3` (AB). خروجی AB. 'prev_string' + 'first_char_current_string' = 'BA'. 'BA' را با کد 4 اضافه کن. 'prev_string' = 'AB'.
    * ...

**خلاصه فصل 7:** فشرده‌سازی داده‌ها برای مدیریت حجم عظیم داده‌های چندرسانه‌ای ضروری است و با حذف افزونگی‌های کدگذاری، فضایی، روان‌بصری و زمانی انجام می‌شود. روش‌ها می‌توانند بدون فقدان (مانند RLC، Huffman، Shannon-Fanon، LZW) یا با فقدان (مانند JPEG) باشند. LZW با دیکشنری پویا، کارایی بالایی در فشرده‌سازی تکرارها دارد.

---

## فصل 8: فشرده‌سازی تصویر (Image Compression) - صفحه 285 تا انتهای 8.5

این فصل به طور مفصل به استانداردهای فشرده‌سازی تصویر و به ویژه الگوریتم JPEG می‌پردازد.

### 8.1 مقدمه (Introduction) - صفحه 285

فشرده‌سازی تصویر برای کاهش حجم فایل‌های تصویری به منظور ذخیره‌سازی و انتقال کارآمد حیاتی است. هدف، دستیابی به بالاترین نسبت فشرده‌سازی ممکن با حداقل از دست دادن کیفیت بصری است.

### 8.2 استانداردهای فشرده‌سازی تصویر (Image Compression Standards) - صفحه 286

* **JPEG (Joint Photographic Experts Group):** رایج‌ترین استاندارد فشرده‌سازی تصویر برای تصاویر ثابت (still images). این استاندارد یک روش فشرده‌سازی با فقدان (lossy) است که بر اساس **تبدیل کسینوسی گسسته (DCT)** عمل می‌کند.
* **JPEG 2000:** یک استاندارد جدیدتر و پیشرفته‌تر که از **تبدیل موجک (Wavelet Transform)** استفاده می‌کند و هم فشرده‌سازی با فقدان و هم بدون فقدان را پشتیبانی می‌کند.
* **PNG (Portable Network Graphics):** یک فرمت تصویر محبوب برای وب که فقط فشرده‌سازی بدون فقدان (lossless) را پشتیبانی می‌کند و جایگزین GIF شده است.

### 8.3 چارچوب فشرده‌سازی تصویر (Image Compression Framework) - صفحه 287

اکثر روش‌های فشرده‌سازی تصویر با فقدان، از یک چارچوب کلی مشابه JPEG پیروی می‌کنند که بر اساس سه مشاهده مهم در HVS (سیستم بینایی انسان) بنا شده است:

* **مشاهده 1 (Observation 1):** "محتوای مفید تصویر (مانند مقادیر روشنایی) در بلاک‌های کوچک (مثلاً 8x8 پیکسل) معمولاً به آرامی تغییر می‌کند." (به این معنی که بیشتر انرژی در فرکانس‌های پایین است).
* **مشاهده 2 (Observation 2):** "چشم انسان به جزئیات فرکانس فضایی بسیار بالا حساسیت کمتری دارد." (به این معنی که می‌توان این اطلاعات را حذف یا با دقت کمتری ذخیره کرد).
* **مشاهده 3 (Observation 3):** "دقت بینایی (Visual Acuity) برای مؤلفه روشنایی (Luminance) بسیار بیشتر از مؤلفه‌های رنگی (Chrominance) است." (به این معنی که می‌توان اطلاعات رنگی را با دقت کمتری ذخیره کرد).

### 8.4 فشرده‌سازی JPEG (JPEG Compression) - صفحه 287

فرآیند فشرده‌سازی JPEG یک **خط لوله (pipeline)** شامل چندین مرحله است:

1.  **تبدیل فضای رنگی (Color Space Transformation: RGB to YCbCr):**
    * **هدف:** بهره‌برداری از مشاهده 3 HVS. تصویر از فرمت RGB (که برای نمایشگرها مناسب است) به فضای رنگی YCbCr تبدیل می‌شود.
    * **فرمول‌های تبدیل (صفحه 287):**
        $$Y = 0.299R + 0.587G + 0.114B$$
        $$Cb = -0.1687R - 0.3313G + 0.5B + 128$$
        $$Cr = 0.5R - 0.4187G - 0.0813B + 128$$
        Y مؤلفه روشنایی (Luminance) است و Cb/Cr مؤلفه‌های رنگی (Chrominance) هستند.

2.  **ساب‌سمپلینگ Chroma (Chroma Subsampling):**
    * **هدف:** کاهش حجم داده‌های رنگی با استفاده از مشاهده 3 HVS.
    * **نحوه کار:** با توجه به حساسیت کمتر چشم انسان به جزئیات رنگی, مؤلفه‌های Cb و Cr با نرخ کمتری نمونه‌برداری می‌شوند. طرح‌های رایج:
        * **4:4:4 (No Subsampling):** هر سه مؤلفه (Y, Cb, Cr) با نرخ کامل نمونه‌برداری می‌شوند (بدون فشرده‌سازی).
        * **4:2:2:** برای هر 2 پیکسل Y در یک ردیف، 1 پیکسل Cb و 1 پیکسل Cr ذخیره می‌شود (نیمی از اطلاعات رنگی افقی).
        * **4:2:0:** برای هر 2x2 بلاک از پیکسل‌های Y، فقط 1 پیکسل Cb و 1 پیکسل Cr ذخیره می‌شود (نیمی از اطلاعات رنگی افقی و نیمی از اطلاعات رنگی عمودی). این رایج‌ترین طرح برای ویدئو و بسیاری از تصاویر JPEG است.
    * **مثال (Figure 8.1, page 288):** نمایش بصری طرح‌های ساب‌سمپلینگ.

3.  **تقسیم به بلاک و شیفت سطح DC (Block Splitting and DC Level Shifting):**
    * **هدف:** آماده‌سازی داده‌ها برای DCT.
    * **تقسیم به بلاک (Blocking):** هر مؤلفه (Y, Cb, Cr) به بلاک‌های 8x8 پیکسل تقسیم می‌شود. این کار به پردازش موازی و کاهش پیچیدگی محاسبات کمک می‌کند.
    * **شیفت سطح DC (DC Level Shifting):** مقادیر هر پیکسل در هر بلاک از محدوده [0, 255] به محدوده [-128, 127] شیفت داده می‌شوند. این کار باعث می‌شود میانگین بلاک حول صفر متمرکز شود که برای DCT بهتر است.

4.  **تبدیل کسینوسی گسسته (Discrete Cosine Transform - DCT):**
    * **هدف:** تبدیل بلاک‌های 8x8 از دامنه فضایی (پیکسل‌ها) به دامنه فرکانس فضایی (ضرایب فرکانسی). این مرحله افزونگی فضایی را حذف می‌کند و انرژی را متمرکز می‌کند (مشاهده 1 HVS).
    * **فرمول DCT 2D (صفحه 288):**
        $$F(u,v) = \frac{1}{4} C(u) C(v) \sum_{x=0}^{7} \sum_{y=0}^{7} f(x,y) \cos\left(\frac{(2x+1)u\pi}{16}\right) \cos\left(\frac{(2y+1)v\pi}{16}\right)$$
        که در آن:
        * $f(x,y)$: مقدار پیکسل در موقعیت $(x,y)$ در بلاک ورودی (پس از شیفت سطح DC).
        * $F(u,v)$: ضریب DCT در موقعیت $(u,v)$ در ماتریس فرکانس.
        * $u,v$: فرکانس‌های فضایی افقی و عمودی (از 0 تا 7).
        * $C(k) = \frac{1}{\sqrt{2}}$ for $k=0$ and $C(k)=1$ for $k>0$.
    * **خروجی:** یک ماتریس 8x8 از ضرایب DCT, $F(u,v)$.
        * $F(0,0)$: ضریب DC. نشان‌دهنده میانگین مقدار بلاک است و حاوی بیشترین انرژی است.
        * $F(u,v)$ برای $u,v > 0$: ضرایب AC. نشان‌دهنده جزئیات فرکانسی بالاتر و تغییرات در بلاک هستند.

5.  **کوانتیزاسیون (Quantization):**
    * **هدف:** کاهش دقت ضرایب DCT با استفاده از یک ماتریس کوانتیزاسیون. این مرحله اصلی‌ترین منبع فشرده‌سازی با فقدان (lossy) در JPEG است و از مشاهده 2 HVS بهره می‌برد.
    * **نحوه کار (صفحه 288):** هر ضریب DCT ($F(u,v)$) بر مقدار متناظر در یک ماتریس کوانتیزاسیون از پیش تعریف شده ($Q(u,v)$) تقسیم شده و سپس به نزدیک‌ترین عدد صحیح گرد می‌شود:
        $$F_{quantized}(u,v) = \text{round}\left(\frac{F(u,v)}{Q(u,v)}\right)$$
    * **ماتریس کوانتیزاسیون (Quantization Table):** این ماتریس (Q) شامل مقادیری است که حساسیت چشم انسان را به فرکانس‌های مختلف در نظر می‌گیرد. مقادیر در گوشه بالا سمت چپ (فرکانس‌های پایین) کوچک‌تر هستند، در حالی که مقادیر در گوشه پایین سمت راست (فرکانس‌های بالا) بزرگ‌تر هستند. این باعث می‌شود که ضرایب فرکانس بالا بیشتر گرد شده یا به صفر تبدیل شوند، زیرا چشم انسان به آن‌ها حساسیت کمتری دارد.
    * **مثال (صفحه 289, Figure 8.3):** ماتریس کوانتیزاسیون نمونه برای Luminance و Chrominance.
        * یک ضریب $F(7,7)$ که 100 است و مقدار $Q(7,7)$ برای آن 255 باشد، پس از کوانتیزاسیون 0 می‌شود ($\text{round}(100/255) = 0$).
        * یک ضریب $F(0,0)$ که 1000 است و مقدار $Q(0,0)$ برای آن 11 باشد، پس از کوانتیزاسیون 91 می‌شود ($\text{round}(1000/11) = 91$).

6.  **کدگذاری آنتروپی (Entropy Encoding):**
    * **هدف:** فشرده‌سازی بدون فقدان (lossless) ضرایب کوانتیزه شده.
    * **پروسه (صفحه 289-290):**
        * **ضرایب DC:**
            * با استفاده از **DPCM (Differential Pulse Code Modulation)** کدگذاری می‌شوند. به جای کدگذاری مقدار مطلق هر $F(0,0)$، تفاوت آن با $F(0,0)$ بلاک قبلی کدگذاری می‌شود. این تفاوت‌ها معمولاً مقادیر کوچکی هستند و بهتر فشرده می‌شوند.
            * هر تفاوت (که در این مرحله **Category** نامیده می‌شود) با یک جفت (Category, Value) نمایش داده می‌شود. Category نشان‌دهنده تعداد بیت‌های مورد نیاز برای نمایش تفاوت است و با کد هافمن (Huffman Code) فشرده می‌شود. Value خود تفاوت واقعی است که به صورت خام ارسال می‌شود.
        * **ضرایب AC:**
            * پس از کوانتیزاسیون، بسیاری از ضرایب AC به صفر تبدیل می‌شوند. برای بهره‌برداری از این "صفر‌های طولانی"، ضرایب AC به ترتیب **زیگزاگ (Zigzag Scan)** پیمایش می‌شوند (صفحه 290, Figure 8.4). این کار باعث می‌شود دنباله‌های طولانی‌تری از صفرها ایجاد شود.
            * سپس از **کدگذاری طول اجرا (Run-Length Coding - RLC)** استفاده می‌شود. هر دنباله از صفرها با یک جفت (RUNLENGTH, SIZE) نمایش داده می‌شود، که RUNLENGTH تعداد صفرها و SIZE تعداد بیت‌های مورد نیاز برای نمایش ضریب AC غیرصفر بعدی است. سپس مقدار واقعی ضریب AC (AMPLITUDE) ارسال می‌شود.
            * جفت (RUNLENGTH, SIZE) با کد هافمن (Huffman Code) فشرده می‌شود، در حالی که AMPLITUDE به صورت خام ارسال می‌شود. یک جفت خاص (0,0) نشان‌دهنده پایان بلاک (End-of-Block - EOB) است.
    * **خروجی:** جریان بیت نهایی JPEG که شامل اطلاعات فشرده شده تصویر است.

### 8.5 مفاهیم تبدیل کسینوسی گسسته (DCT Concepts) - صفحه 291

* **DCT به عنوان یک تبدیل پایه (Basis Transform):**
    * DCT یک بلاک تصویر را به ترکیبی خطی از 64 تابع پایه کسینوسی (Figure 8.5a, page 292) تجزیه می‌کند.
    * ضریب $F(u,v)$ نشان‌دهنده وزن آن تابع پایه در بازسازی تصویر است.
    * **مثال (Figure 8.5b, page 292):** نشان می‌دهد چگونه یک تصویر ساده (مثلاً یک خط افقی) می‌تواند با تعداد کمی از توابع پایه DCT (به ویژه فرکانس‌های پایین) بازسازی شود.
* **متمرکز کردن انرژی (Energy Compaction):**
    * مهم‌ترین خاصیت DCT برای فشرده‌سازی.
    * اکثر انرژی تصویر در چند ضریب فرکانس پایین ($F(0,0)$ و ضرایب AC اطراف آن) متمرکز می‌شود.
    * **مثال (Figure 8.6, page 293):** نشان می‌دهد چگونه ضرایب DCT به سمت گوشه بالا سمت چپ ماتریس (فرکانس‌های پایین) مقادیر بزرگتری دارند. این امکان حذف/کوانتیزه کردن ضرایب فرکانس بالا را فراهم می‌کند.
* **دکورله کردن (Decorrelation):**
    * DCT همبستگی بین پیکسل‌های مجاور در دامنه فضایی را به طور قابل توجهی کاهش می‌دهد.
    * ضرایب DCT ($F_{uv}$) نسبت به پیکسل‌های اصلی ($F_{xy}$) کمتر به یکدیگر وابسته هستند، که این امر برای مراحل کوانتیزاسیون و کدگذاری آنتروپی مفید است.
* **ویژگی سیگنال $f(x)$ اگر فقط $F(0)$ غیرصفر باشد (صفحه 294, Figure 8.7):**
    * **سوال:** اگر در بردار $f(x)$ که با DCT یک بعدی به $F(u)$ تبدیل شده است، تمام درایه‌های $F(u)$ به جز $F(0)$ صفر باشند، $f(x)$ چه ویژگی دارد؟
    * **پاسخ:** اگر تنها $F(0)$ غیرصفر باشد، به این معنی است که سیگنال $f(x)$ یک **سیگنال ثابت (Constant Signal)** است (یعنی تمام درایه‌های آن دارای یک مقدار یکسان هستند).
    * **مثال از کتاب (Figure 8.7a, page 294):** سیگنال $f_1(i) = 100$ (یک سیگنال ثابت). تبدیل DCT آن $F_1(u)$ فقط $F_1(0) = 282.84$ دارد و بقیه صفرند.
    * **فرمول DCT یک بعدی (صفحه 293):**
        $$F(u) = C(u) \sum_{x=0}^{N-1} f(x) \cos\left(\frac{(2x+1)u\pi}{2N}\right)$$
        برای $N=8$.
        $F(0)$ مربوط به مؤلفه DC (میانگین) است. اگر سایر ضرایب (AC) صفر باشند، یعنی هیچ تغییری در سیگنال وجود ندارد.

**خلاصه فصل 8.1-8.5:** JPEG یک استاندارد فشرده‌سازی با فقدان برای تصاویر است که از ویژگی‌های HVS بهره می‌برد. مراحل کلیدی آن شامل تبدیل فضای رنگی، ساب‌سمپلینگ (فقدان)، تقسیم به بلاک، DCT (دکورله کردن و تمرکز انرژی)، کوانتیزاسیون (اصلی‌ترین مرحله فقدان) و کدگذاری آنتروپی (بدون فقدان) است. DCT با تجزیه تصویر به فرکانس‌ها، امکان فشرده‌سازی هوشمند را فراهم می‌کند.

---

## فصل 9: فشرده‌سازی ویدئو (Video Compression) - فقط 9.1 - صفحه 303

### 9.1 مقدمه به فشرده‌سازی ویدئو (Introduction to Video Compression)

ویدئو یک دنباله از تصاویر ثابت (فریم‌ها) است که با سرعت مشخصی نمایش داده می‌شوند. حجم داده‌های ویدئویی خام بسیار زیاد است. به عنوان مثال، یک دقیقه ویدئوی دیجیتال با کیفیت بالا می‌تواند صدها مگابایت یا گیگابایت حجم داشته باشد. بنابراین، فشرده‌سازی ویدئو برای ذخیره‌سازی، انتقال و استریمینگ آن ضروری است.

**افزونگی‌ها در دنباله‌های ویدئویی (Redundancies in Video Sequences) - صفحه 303:**
فشرده‌سازی ویدئو بر اساس حذف سه نوع اصلی افزونگی در دنباله‌های ویدئویی صورت می‌گیرد:

1.  **افزونگی فضایی (Spatial Redundancy):**
    * **تعریف:** این افزونگی به وجود همبستگی بین پیکسل‌های مجاور درون یک فریم واحد اشاره دارد. همانطور که در فصل 8 برای تصاویر ثابت دیدیم، پیکسل‌های نزدیک به هم اغلب مقادیر رنگی یا روشنایی مشابهی دارند.
    * **نحوه حذف:** این نوع افزونگی با استفاده از تکنیک‌های فشرده‌سازی تصویر که برای تصاویر ثابت استفاده می‌شوند، حذف می‌شود. این شامل:
        * **تبدیل (Transform):** مانند DCT (Discrete Cosine Transform) که همبستگی بین پیکسل‌ها را کاهش می‌دهد و انرژی تصویر را در چند ضریب فرکانس پایین متمرکز می‌کند.
        * **کوانتیزاسیون (Quantization):** حذف اطلاعات کم‌اهمیت (معمولاً فرکانس‌های بالا) با گرد کردن ضرایب تبدیل.
        * **کدگذاری آنتروپی (Entropy Coding):** فشرده‌سازی بدون فقدان ضرایب باقیمانده.
    * **مثال:** یک فریم ویدئو می‌تواند به بلاک‌های 8x8 تقسیم شود و هر بلاک به صورت جداگانه با استفاده از فرآیندی شبیه به JPEG فشرده شود.

2.  **افزونگی زمانی (Temporal Redundancy):**
    * **تعریف:** این مهم‌ترین شکل افزونگی در ویدئو است. به شباهت زیاد بین فریم‌های متوالی در یک دنباله ویدئویی اشاره دارد. به دلیل نرخ فریم نسبتاً بالا (مثلاً 25 یا 30 فریم بر ثانیه)، بیشتر مناطق یک فریم در فریم‌های قبلی و بعدی نیز وجود دارند (مانند پس‌زمینه ثابت یا اشیاء متحرک).
    * **نحوه حذف:** این افزونگی با استفاده از تکنیک‌های **کدگذاری بین فریمی (Interframe Coding)**، که شامل **تخمین حرکت (Motion Estimation)** و **جبران حرکت (Motion Compensation)** است، حذف می‌شود.
        * **تخمین حرکت (Motion Estimation):** هدف یافتن جابجایی پیکسل‌ها یا بلاک‌های پیکسل‌ها بین فریم فعلی و فریم‌های مرجع (معمولاً فریم‌های قبلی). این جابجایی‌ها به صورت **بردارهای حرکت (Motion Vectors)** بیان می‌شوند.
        * **جبران حرکت (Motion Compensation):** با استفاده از بردارهای حرکت، بلاک‌هایی از فریم مرجع جابجا می‌شوند تا بهترین تخمین را برای بلاک‌های متناظر در فریم فعلی ارائه دهند.
        * **کدگذاری خطای پیش‌بینی (Prediction Error Coding):** تفاوت بین بلاک واقعی در فریم فعلی و بلاک پیش‌بینی شده از فریم مرجع (که "**بلاک اختلاف**" یا "**residual block**" نامیده می‌شود) محاسبه و کدگذاری می‌شود. از آنجایی که این بلاک اختلاف معمولاً شامل اطلاعات بسیار کمتری نسبت به خود بلاک اصلی است، به شدت فشرده می‌شود.
    * **مثال (Figure 9.1, page 304):** شکل 9.1a نشان می‌دهد که اکثر محتوای فریم‌های متوالی مشابه هستند. شکل 9.1b نشان می‌دهد که به جای کدگذاری کل فریم، فقط یک بلاک اختلاف (که مقدارش نزدیک به صفر است) و یک بردار حرکت کدگذاری می‌شود.

3.  **افزونگی روان‌بصری (Psychovisual Redundancy):**
    * **تعریف:** این افزونگی به ویژگی‌های سیستم بینایی انسان مربوط می‌شود که باعث می‌شود به برخی از جزئیات بصری کمتر حساس باشد.
    * **نحوه حذف:** این افزونگی از طریق فرآیند **کوانتیزاسیون (Quantization)** (مشابه JPEG) و حذف جزئیات بصری نامحسوس (مانند فرکانس‌های فضایی بسیار بالا یا جزئیات رنگی ریز) بهره‌برداری می‌شود. این مرحله منجر به فشرده‌سازی با فقدان می‌شود.

**چالش‌ها و مدل فشرده‌سازی ویدئو:**
فشرده‌سازی ویدئو یک فرآیند پیچیده است زیرا باید هر سه نوع افزونگی را به طور مؤثر حذف کند. استانداردها مانند MPEG (که در فصول بعدی کتاب به آن پرداخته می‌شود) از یک رویکرد **هیبریدی (Hybrid Approach)** استفاده می‌کنند که ترکیبی از حذف افزونگی زمانی (با تخمین/جبران حرکت) و حذف افزونگی فضایی (با DCT و کوانتیزاسیون) است.

**خلاصه فصل 9.1:** فشرده‌سازی ویدئو برای مقابله با حجم عظیم داده‌ها ضروری است. این کار با حذف سه نوع افزونگی: فضایی (مشابه فشرده‌سازی تصویر)، زمانی (با تخمین و جبران حرکت بین فریم‌ها)، و روان‌بصری (با بهره‌برداری از ویژگی‌های چشم انسان) انجام می‌شود. افزونگی زمانی مهم‌ترین نقش را در دستیابی به نسبت‌های فشرده‌سازی بالا در ویدئو ایفا می‌کند.